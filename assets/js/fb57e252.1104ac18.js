"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8680],{3905:function(a,e,n){n.r(e),n.d(e,{MDXContext:function(){return l},MDXProvider:function(){return c},mdx:function(){return h},useMDXComponents:function(){return d},withMDXComponents:function(){return o}});var m=n(67294);function t(a,e,n){return e in a?Object.defineProperty(a,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):a[e]=n,a}function s(){return s=Object.assign||function(a){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var m in n)Object.prototype.hasOwnProperty.call(n,m)&&(a[m]=n[m])}return a},s.apply(this,arguments)}function r(a,e){var n=Object.keys(a);if(Object.getOwnPropertySymbols){var m=Object.getOwnPropertySymbols(a);e&&(m=m.filter((function(e){return Object.getOwnPropertyDescriptor(a,e).enumerable}))),n.push.apply(n,m)}return n}function p(a){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?r(Object(n),!0).forEach((function(e){t(a,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(a,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(e){Object.defineProperty(a,e,Object.getOwnPropertyDescriptor(n,e))}))}return a}function i(a,e){if(null==a)return{};var n,m,t=function(a,e){if(null==a)return{};var n,m,t={},s=Object.keys(a);for(m=0;m<s.length;m++)n=s[m],e.indexOf(n)>=0||(t[n]=a[n]);return t}(a,e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(a);for(m=0;m<s.length;m++)n=s[m],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(a,n)&&(t[n]=a[n])}return t}var l=m.createContext({}),o=function(a){return function(e){var n=d(e.components);return m.createElement(a,s({},e,{components:n}))}},d=function(a){var e=m.useContext(l),n=e;return a&&(n="function"==typeof a?a(e):p(p({},e),a)),n},c=function(a){var e=d(a.components);return m.createElement(l.Provider,{value:e},a.children)},N={inlineCode:"code",wrapper:function(a){var e=a.children;return m.createElement(m.Fragment,{},e)}},x=m.forwardRef((function(a,e){var n=a.components,t=a.mdxType,s=a.originalType,r=a.parentName,l=i(a,["components","mdxType","originalType","parentName"]),o=d(n),c=t,x=o["".concat(r,".").concat(c)]||o[c]||N[c]||s;return n?m.createElement(x,p(p({ref:e},l),{},{components:n})):m.createElement(x,p({ref:e},l))}));function h(a,e){var n=arguments,t=e&&e.mdxType;if("string"==typeof a||t){var s=n.length,r=new Array(s);r[0]=x;var p={};for(var i in e)hasOwnProperty.call(e,i)&&(p[i]=e[i]);p.originalType=a,p.mdxType="string"==typeof a?a:t,r[1]=p;for(var l=2;l<s;l++)r[l]=n[l];return m.createElement.apply(null,r)}return m.createElement.apply(null,n)}x.displayName="MDXCreateElement"},85471:function(a,e,n){n.r(e),n.d(e,{frontMatter:function(){return p},contentTitle:function(){return i},metadata:function(){return l},toc:function(){return o},default:function(){return c}});var m=n(87462),t=n(63366),s=(n(67294),n(3905)),r=["components"],p={id:"random_walk",title:"Single-Site Random Walk Metropolis-Hastings",sidebar_label:"Single-Site Random Walk MH",slug:"/random_walk"},i=void 0,l={unversionedId:"framework_topics/inference/random_walk",id:"framework_topics/inference/random_walk",title:"Single-Site Random Walk Metropolis-Hastings",description:"Random Walk Metropolis-Hastings is a simple, minimal MCMC inference method. Random Walk Metropolis-Hastings is single-site by default, following the philosophy of most inference methods in Bean Machine, and accordingly multi-site inference patterns are well supported. Random Walk Metropolis-Hastings follows the standard Metropolis-Hastings algorithm of sampling a value from a proposal distribution, and then running accept-reject according to the computed ratio of the proposed value. This is further detailed in the docs for Ancestral Metropolis-Hastings. This tutorial describes the proposal mechanism, describes adaptive Random Walk Metropolis-Hastings, and documents the API for the Random Walk Metropolis-Hastings algorithm.",source:"@site/../docs/framework_topics/inference/random_walk.md",sourceDirName:"framework_topics/inference",slug:"/random_walk",permalink:"/docs/random_walk",editUrl:"https://github.com/facebookresearch/beanmachine/edit/main/website/../docs/framework_topics/inference/random_walk.md",tags:[],version:"current",frontMatter:{id:"random_walk",title:"Single-Site Random Walk Metropolis-Hastings",sidebar_label:"Single-Site Random Walk MH",slug:"/random_walk"},sidebar:"someSidebar",previous:{title:"Single-Site Ancestral MH",permalink:"/docs/ancestral_metropolis_hastings"},next:{title:"Single-Site Uniform MH",permalink:"/docs/uniform_metropolis_hastings"}},o=[{value:"Algorithm",id:"algorithm",children:[],level:2},{value:"Adaptive Random Walk Metropolis-Hastings",id:"adaptive-random-walk-metropolis-hastings",children:[],level:2},{value:"Usage",id:"usage",children:[],level:2}],d={toc:o};function c(a){var e=a.components,n=(0,t.Z)(a,r);return(0,s.mdx)("wrapper",(0,m.Z)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,s.mdx)("p",null,"Random Walk Metropolis-Hastings is a simple, minimal MCMC inference method. Random Walk Metropolis-Hastings is single-site by default, following the philosophy of most inference methods in Bean Machine, and accordingly multi-site inference patterns are well supported. Random Walk Metropolis-Hastings follows the standard Metropolis-Hastings algorithm of sampling a value from a proposal distribution, and then running accept-reject according to the computed ratio of the proposed value. This is further detailed in the docs for ",(0,s.mdx)("a",{parentName:"p",href:"/docs/ancestral_metropolis_hastings"},"Ancestral Metropolis-Hastings"),". This tutorial describes the proposal mechanism, describes adaptive Random Walk Metropolis-Hastings, and documents the API for the Random Walk Metropolis-Hastings algorithm."),(0,s.mdx)("h2",{id:"algorithm"},"Algorithm"),(0,s.mdx)("p",null,"Random Walk Metropolis-Hastings works on a single-site basis by proposing new values for a random variable that are close to the current value according to some sense of distance. As such, it is only defined for continuous random variables. The exact distance that a proposed value is from the current value is defined by the ",(0,s.mdx)("em",{parentName:"p"},"proposal distribution"),", and is a parameter that can be provided when configuring the inference method. For discrete random variables, a similar effect may be achieved, but ",(0,s.mdx)("a",{parentName:"p",href:"/docs/custom_proposers"},"custom proposers")," must be used instead."),(0,s.mdx)("p",null,"The Random Walk Metropolis-Hastings algorithm has multiple proposers defined on different spaces such as all real numbers, positive real numbers, or intervals of the real numbers. These proposers all have common properties used to propose a new value ",(0,s.mdx)("span",{parentName:"p",className:"math math-inline"},(0,s.mdx)("span",{parentName:"span",className:"katex"},(0,s.mdx)("span",{parentName:"span",className:"katex-mathml"},(0,s.mdx)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.mdx)("semantics",{parentName:"math"},(0,s.mdx)("mrow",{parentName:"semantics"},(0,s.mdx)("msup",{parentName:"mrow"},(0,s.mdx)("mi",{parentName:"msup"},"x"),(0,s.mdx)("mo",{parentName:"msup",mathvariant:"normal"},"\u2032"))),(0,s.mdx)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"x^\\prime")))),(0,s.mdx)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.mdx)("span",{parentName:"span",className:"base"},(0,s.mdx)("span",{parentName:"span",className:"strut",style:{height:"0.751892em",verticalAlign:"0em"}}),(0,s.mdx)("span",{parentName:"span",className:"mord"},(0,s.mdx)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,s.mdx)("span",{parentName:"span",className:"msupsub"},(0,s.mdx)("span",{parentName:"span",className:"vlist-t"},(0,s.mdx)("span",{parentName:"span",className:"vlist-r"},(0,s.mdx)("span",{parentName:"span",className:"vlist",style:{height:"0.751892em"}},(0,s.mdx)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,s.mdx)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,s.mdx)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,s.mdx)("span",{parentName:"span",className:"mord mtight"},"\u2032"))))))))))))," from a current value ",(0,s.mdx)("span",{parentName:"p",className:"math math-inline"},(0,s.mdx)("span",{parentName:"span",className:"katex"},(0,s.mdx)("span",{parentName:"span",className:"katex-mathml"},(0,s.mdx)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.mdx)("semantics",{parentName:"math"},(0,s.mdx)("mrow",{parentName:"semantics"},(0,s.mdx)("mi",{parentName:"mrow"},"x")),(0,s.mdx)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"x")))),(0,s.mdx)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.mdx)("span",{parentName:"span",className:"base"},(0,s.mdx)("span",{parentName:"span",className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}}),(0,s.mdx)("span",{parentName:"span",className:"mord mathnormal"},"x"))))),". The proposal distribution ",(0,s.mdx)("span",{parentName:"p",className:"math math-inline"},(0,s.mdx)("span",{parentName:"span",className:"katex"},(0,s.mdx)("span",{parentName:"span",className:"katex-mathml"},(0,s.mdx)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.mdx)("semantics",{parentName:"math"},(0,s.mdx)("mrow",{parentName:"semantics"},(0,s.mdx)("mi",{parentName:"mrow"},"q"),(0,s.mdx)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.mdx)("mi",{parentName:"mrow"},"x"),(0,s.mdx)("mo",{parentName:"mrow",separator:"true"},","),(0,s.mdx)("msup",{parentName:"mrow"},(0,s.mdx)("mi",{parentName:"msup"},"x"),(0,s.mdx)("mo",{parentName:"msup",mathvariant:"normal"},"\u2032")),(0,s.mdx)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,s.mdx)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"q(x,x^\\prime)")))),(0,s.mdx)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.mdx)("span",{parentName:"span",className:"base"},(0,s.mdx)("span",{parentName:"span",className:"strut",style:{height:"1.001892em",verticalAlign:"-0.25em"}}),(0,s.mdx)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"q"),(0,s.mdx)("span",{parentName:"span",className:"mopen"},"("),(0,s.mdx)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,s.mdx)("span",{parentName:"span",className:"mpunct"},","),(0,s.mdx)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,s.mdx)("span",{parentName:"span",className:"mord"},(0,s.mdx)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,s.mdx)("span",{parentName:"span",className:"msupsub"},(0,s.mdx)("span",{parentName:"span",className:"vlist-t"},(0,s.mdx)("span",{parentName:"span",className:"vlist-r"},(0,s.mdx)("span",{parentName:"span",className:"vlist",style:{height:"0.751892em"}},(0,s.mdx)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,s.mdx)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,s.mdx)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,s.mdx)("span",{parentName:"span",className:"mord mtight"},"\u2032")))))))),(0,s.mdx)("span",{parentName:"span",className:"mclose"},")")))))," is constructed to satisfy the following properties:"),(0,s.mdx)("div",{className:"math math-display"},(0,s.mdx)("span",{parentName:"div",className:"katex-display"},(0,s.mdx)("span",{parentName:"span",className:"katex"},(0,s.mdx)("span",{parentName:"span",className:"katex-mathml"},(0,s.mdx)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},(0,s.mdx)("semantics",{parentName:"math"},(0,s.mdx)("mtable",{parentName:"semantics",rowspacing:"0.24999999999999992em",columnalign:"right left",columnspacing:"0em"},(0,s.mdx)("mtr",{parentName:"mtable"},(0,s.mdx)("mtd",{parentName:"mtr"},(0,s.mdx)("mstyle",{parentName:"mtd",scriptlevel:"0",displaystyle:"true"},(0,s.mdx)("mrow",{parentName:"mstyle"},(0,s.mdx)("mi",{parentName:"mrow",mathvariant:"double-struck"},"E"),(0,s.mdx)("mo",{parentName:"mrow",stretchy:"false"},"["),(0,s.mdx)("mi",{parentName:"mrow"},"q"),(0,s.mdx)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.mdx)("mi",{parentName:"mrow"},"x"),(0,s.mdx)("mo",{parentName:"mrow",separator:"true"},","),(0,s.mdx)("mo",{parentName:"mrow"},"\u22c5"),(0,s.mdx)("mo",{parentName:"mrow",stretchy:"false"},")"),(0,s.mdx)("mo",{parentName:"mrow",stretchy:"false"},"]")))),(0,s.mdx)("mtd",{parentName:"mtr"},(0,s.mdx)("mstyle",{parentName:"mtd",scriptlevel:"0",displaystyle:"true"},(0,s.mdx)("mrow",{parentName:"mstyle"},(0,s.mdx)("mrow",{parentName:"mrow"}),(0,s.mdx)("mo",{parentName:"mrow"},"="),(0,s.mdx)("mi",{parentName:"mrow"},"x"))))),(0,s.mdx)("mtr",{parentName:"mtable"},(0,s.mdx)("mtd",{parentName:"mtr"},(0,s.mdx)("mstyle",{parentName:"mtd",scriptlevel:"0",displaystyle:"true"},(0,s.mdx)("mrow",{parentName:"mstyle"},(0,s.mdx)("mi",{parentName:"mrow",mathvariant:"double-struck"},"V"),(0,s.mdx)("mo",{parentName:"mrow",stretchy:"false"},"["),(0,s.mdx)("mi",{parentName:"mrow"},"q"),(0,s.mdx)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.mdx)("mi",{parentName:"mrow"},"x"),(0,s.mdx)("mo",{parentName:"mrow",separator:"true"},","),(0,s.mdx)("mo",{parentName:"mrow"},"\u22c5"),(0,s.mdx)("mo",{parentName:"mrow",stretchy:"false"},")"),(0,s.mdx)("mo",{parentName:"mrow",stretchy:"false"},"]")))),(0,s.mdx)("mtd",{parentName:"mtr"},(0,s.mdx)("mstyle",{parentName:"mtd",scriptlevel:"0",displaystyle:"true"},(0,s.mdx)("mrow",{parentName:"mstyle"},(0,s.mdx)("mrow",{parentName:"mrow"}),(0,s.mdx)("mo",{parentName:"mrow"},"="),(0,s.mdx)("msup",{parentName:"mrow"},(0,s.mdx)("mi",{parentName:"msup"},"\u03c3"),(0,s.mdx)("mn",{parentName:"msup"},"2"))))))),(0,s.mdx)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\begin{aligned} \\mathbb{E}[q(x, \\cdot)] &= x \\\\ \\mathbb{V} [q(x, \\cdot)] &= \\sigma^2 \\end{aligned}")))),(0,s.mdx)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.mdx)("span",{parentName:"span",className:"base"},(0,s.mdx)("span",{parentName:"span",className:"strut",style:{height:"3.024108em",verticalAlign:"-1.262054em"}}),(0,s.mdx)("span",{parentName:"span",className:"mord"},(0,s.mdx)("span",{parentName:"span",className:"mtable"},(0,s.mdx)("span",{parentName:"span",className:"col-align-r"},(0,s.mdx)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,s.mdx)("span",{parentName:"span",className:"vlist-r"},(0,s.mdx)("span",{parentName:"span",className:"vlist",style:{height:"1.762054em"}},(0,s.mdx)("span",{parentName:"span",style:{top:"-3.922054em"}},(0,s.mdx)("span",{parentName:"span",className:"pstrut",style:{height:"3em"}}),(0,s.mdx)("span",{parentName:"span",className:"mord"},(0,s.mdx)("span",{parentName:"span",className:"mord"},(0,s.mdx)("span",{parentName:"span",className:"mord mathbb"},"E")),(0,s.mdx)("span",{parentName:"span",className:"mopen"},"["),(0,s.mdx)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"q"),(0,s.mdx)("span",{parentName:"span",className:"mopen"},"("),(0,s.mdx)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,s.mdx)("span",{parentName:"span",className:"mpunct"},","),(0,s.mdx)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,s.mdx)("span",{parentName:"span",className:"mord"},"\u22c5"),(0,s.mdx)("span",{parentName:"span",className:"mclose"},")"),(0,s.mdx)("span",{parentName:"span",className:"mclose"},"]"))),(0,s.mdx)("span",{parentName:"span",style:{top:"-2.397946em"}},(0,s.mdx)("span",{parentName:"span",className:"pstrut",style:{height:"3em"}}),(0,s.mdx)("span",{parentName:"span",className:"mord"},(0,s.mdx)("span",{parentName:"span",className:"mord"},(0,s.mdx)("span",{parentName:"span",className:"mord mathbb"},"V")),(0,s.mdx)("span",{parentName:"span",className:"mopen"},"["),(0,s.mdx)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"q"),(0,s.mdx)("span",{parentName:"span",className:"mopen"},"("),(0,s.mdx)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,s.mdx)("span",{parentName:"span",className:"mpunct"},","),(0,s.mdx)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,s.mdx)("span",{parentName:"span",className:"mord"},"\u22c5"),(0,s.mdx)("span",{parentName:"span",className:"mclose"},")"),(0,s.mdx)("span",{parentName:"span",className:"mclose"},"]")))),(0,s.mdx)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,s.mdx)("span",{parentName:"span",className:"vlist-r"},(0,s.mdx)("span",{parentName:"span",className:"vlist",style:{height:"1.262054em"}},(0,s.mdx)("span",{parentName:"span"}))))),(0,s.mdx)("span",{parentName:"span",className:"col-align-l"},(0,s.mdx)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,s.mdx)("span",{parentName:"span",className:"vlist-r"},(0,s.mdx)("span",{parentName:"span",className:"vlist",style:{height:"1.762054em"}},(0,s.mdx)("span",{parentName:"span",style:{top:"-3.922054em"}},(0,s.mdx)("span",{parentName:"span",className:"pstrut",style:{height:"3em"}}),(0,s.mdx)("span",{parentName:"span",className:"mord"},(0,s.mdx)("span",{parentName:"span",className:"mord"}),(0,s.mdx)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}}),(0,s.mdx)("span",{parentName:"span",className:"mrel"},"="),(0,s.mdx)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}}),(0,s.mdx)("span",{parentName:"span",className:"mord mathnormal"},"x"))),(0,s.mdx)("span",{parentName:"span",style:{top:"-2.397946em"}},(0,s.mdx)("span",{parentName:"span",className:"pstrut",style:{height:"3em"}}),(0,s.mdx)("span",{parentName:"span",className:"mord"},(0,s.mdx)("span",{parentName:"span",className:"mord"}),(0,s.mdx)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}}),(0,s.mdx)("span",{parentName:"span",className:"mrel"},"="),(0,s.mdx)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}}),(0,s.mdx)("span",{parentName:"span",className:"mord"},(0,s.mdx)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"\u03c3"),(0,s.mdx)("span",{parentName:"span",className:"msupsub"},(0,s.mdx)("span",{parentName:"span",className:"vlist-t"},(0,s.mdx)("span",{parentName:"span",className:"vlist-r"},(0,s.mdx)("span",{parentName:"span",className:"vlist",style:{height:"0.8641079999999999em"}},(0,s.mdx)("span",{parentName:"span",style:{top:"-3.113em",marginRight:"0.05em"}},(0,s.mdx)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,s.mdx)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,s.mdx)("span",{parentName:"span",className:"mord mtight"},"2"))))))))))),(0,s.mdx)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,s.mdx)("span",{parentName:"span",className:"vlist-r"},(0,s.mdx)("span",{parentName:"span",className:"vlist",style:{height:"1.262054em"}},(0,s.mdx)("span",{parentName:"span"})))))))))))),(0,s.mdx)("p",null,(0,s.mdx)("span",{parentName:"p",className:"math math-inline"},(0,s.mdx)("span",{parentName:"span",className:"katex"},(0,s.mdx)("span",{parentName:"span",className:"katex-mathml"},(0,s.mdx)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.mdx)("semantics",{parentName:"math"},(0,s.mdx)("mrow",{parentName:"semantics"},(0,s.mdx)("mi",{parentName:"mrow"},"\u03c3")),(0,s.mdx)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\sigma")))),(0,s.mdx)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.mdx)("span",{parentName:"span",className:"base"},(0,s.mdx)("span",{parentName:"span",className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}}),(0,s.mdx)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"\u03c3")))))," is the parameter that may be provided as a parameter when configuring the inference method, and it must be a fixed positive number. Larger values of ",(0,s.mdx)("span",{parentName:"p",className:"math math-inline"},(0,s.mdx)("span",{parentName:"span",className:"katex"},(0,s.mdx)("span",{parentName:"span",className:"katex-mathml"},(0,s.mdx)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.mdx)("semantics",{parentName:"math"},(0,s.mdx)("mrow",{parentName:"semantics"},(0,s.mdx)("mi",{parentName:"mrow"},"\u03c3")),(0,s.mdx)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\sigma")))),(0,s.mdx)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.mdx)("span",{parentName:"span",className:"base"},(0,s.mdx)("span",{parentName:"span",className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}}),(0,s.mdx)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"\u03c3")))))," will cause the inference method to explore more non-local values for ",(0,s.mdx)("span",{parentName:"p",className:"math math-inline"},(0,s.mdx)("span",{parentName:"span",className:"katex"},(0,s.mdx)("span",{parentName:"span",className:"katex-mathml"},(0,s.mdx)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.mdx)("semantics",{parentName:"math"},(0,s.mdx)("mrow",{parentName:"semantics"},(0,s.mdx)("mi",{parentName:"mrow"},"X")),(0,s.mdx)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"X")))),(0,s.mdx)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.mdx)("span",{parentName:"span",className:"base"},(0,s.mdx)("span",{parentName:"span",className:"strut",style:{height:"0.68333em",verticalAlign:"0em"}}),(0,s.mdx)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.07847em"}},"X"))))),". This may be good for faster exploration of the posterior, but it may cause lower probability values to get proposed (and therefore rejected) as a result."),(0,s.mdx)("h2",{id:"adaptive-random-walk-metropolis-hastings"},"Adaptive Random Walk Metropolis-Hastings"),(0,s.mdx)("p",null,"Selecting a good ",(0,s.mdx)("span",{parentName:"p",className:"math math-inline"},(0,s.mdx)("span",{parentName:"span",className:"katex"},(0,s.mdx)("span",{parentName:"span",className:"katex-mathml"},(0,s.mdx)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.mdx)("semantics",{parentName:"math"},(0,s.mdx)("mrow",{parentName:"semantics"},(0,s.mdx)("mi",{parentName:"mrow"},"\u03c3")),(0,s.mdx)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\sigma")))),(0,s.mdx)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.mdx)("span",{parentName:"span",className:"base"},(0,s.mdx)("span",{parentName:"span",className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}}),(0,s.mdx)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"\u03c3")))))," value is important for efficient posterior exploration. However, it is often challenging for a user to select a good ",(0,s.mdx)("span",{parentName:"p",className:"math math-inline"},(0,s.mdx)("span",{parentName:"span",className:"katex"},(0,s.mdx)("span",{parentName:"span",className:"katex-mathml"},(0,s.mdx)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.mdx)("semantics",{parentName:"math"},(0,s.mdx)("mrow",{parentName:"semantics"},(0,s.mdx)("mi",{parentName:"mrow"},"\u03c3")),(0,s.mdx)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\sigma")))),(0,s.mdx)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.mdx)("span",{parentName:"span",className:"base"},(0,s.mdx)("span",{parentName:"span",className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}}),(0,s.mdx)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"\u03c3")))))," value, as it requires a nuanced understanding of the posterior space. Consequently, Bean Machine provides an adaptive version of Random Walk Metropolis-Hastings, in which the inference engine automatically tunes the value of ",(0,s.mdx)("span",{parentName:"p",className:"math math-inline"},(0,s.mdx)("span",{parentName:"span",className:"katex"},(0,s.mdx)("span",{parentName:"span",className:"katex-mathml"},(0,s.mdx)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.mdx)("semantics",{parentName:"math"},(0,s.mdx)("mrow",{parentName:"semantics"},(0,s.mdx)("mi",{parentName:"mrow"},"\u03c3")),(0,s.mdx)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\sigma")))),(0,s.mdx)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.mdx)("span",{parentName:"span",className:"base"},(0,s.mdx)("span",{parentName:"span",className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}}),(0,s.mdx)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"\u03c3")))))," during the first few samples of inference (known as the adaptation period)."),(0,s.mdx)("p",null,"The Random Walk Metropolis-Hastings algorithm is an exemplar use of the Bean Machine pattern for Adaptive inference, and this is enabled by using the argument ",(0,s.mdx)("inlineCode",{parentName:"p"},"num_adaptive_samples")," in the call to ",(0,s.mdx)("inlineCode",{parentName:"p"},"infer()"),". This causes Bean Machine to run an adaptation phase at the beginning of inference for the provided number of samples. During this phase, Bean Machine will internally tweak values of ",(0,s.mdx)("span",{parentName:"p",className:"math math-inline"},(0,s.mdx)("span",{parentName:"span",className:"katex"},(0,s.mdx)("span",{parentName:"span",className:"katex-mathml"},(0,s.mdx)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.mdx)("semantics",{parentName:"math"},(0,s.mdx)("mrow",{parentName:"semantics"},(0,s.mdx)("mi",{parentName:"mrow"},"\u03c3")),(0,s.mdx)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\sigma")))),(0,s.mdx)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.mdx)("span",{parentName:"span",className:"base"},(0,s.mdx)("span",{parentName:"span",className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}}),(0,s.mdx)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"\u03c3")))))," in order to find the largest value that still results in a relatively low number of rejected proposals. Technically speaking, Random Walk adaptation will attempt to achieve an amortized acceptance rate of 0.234. How this value is chosen as the optimal acceptance rate is detailed in ",(0,s.mdx)("a",{parentName:"p",href:"http://www.stats.ox.ac.uk/~evans/CDT/Adaptive.pdf"},"Optional Scaling and Adaptive Markov Chain Monte Carlo"),"."),(0,s.mdx)("p",null,"Please note that samples taken during adaptation are not valid posterior samples, and so will not be shown by default when using the ",(0,s.mdx)("inlineCode",{parentName:"p"},"MonteCarloSamples")," object returned from inference."),(0,s.mdx)("h2",{id:"usage"},"Usage"),(0,s.mdx)("p",null,"The following code snippet illustrates how to use the inference method. Here, ",(0,s.mdx)("inlineCode",{parentName:"p"},"step_size")," represents ",(0,s.mdx)("span",{parentName:"p",className:"math math-inline"},(0,s.mdx)("span",{parentName:"span",className:"katex"},(0,s.mdx)("span",{parentName:"span",className:"katex-mathml"},(0,s.mdx)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.mdx)("semantics",{parentName:"math"},(0,s.mdx)("mrow",{parentName:"semantics"},(0,s.mdx)("mi",{parentName:"mrow"},"\u03c3")),(0,s.mdx)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\sigma")))),(0,s.mdx)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.mdx)("span",{parentName:"span",className:"base"},(0,s.mdx)("span",{parentName:"span",className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}}),(0,s.mdx)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"\u03c3")))))," from the algorithm above."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-py"},"samples = bm.SingleSiteRandomWalk(\n  step_size = 2.0,\n).infer(\n  queries,\n  observations,\n  num_adapt_steps = 1000,\n  num_steps = 200,\n)\n")),(0,s.mdx)("p",null,"If desired, ",(0,s.mdx)("inlineCode",{parentName:"p"},"step_size")," does not need to be set, and it will be initialized to the default initial value ",(0,s.mdx)("inlineCode",{parentName:"p"},"1.0"),". Either way, if ",(0,s.mdx)("inlineCode",{parentName:"p"},"num_adapt_steps > 0")," is set, then ",(0,s.mdx)("inlineCode",{parentName:"p"},"step_size")," will be changed after inference begins."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-py"},"samples = bm.SingleSiteRandomWalk().infer(\n  queries,\n  observations,\n  num_adapt_steps = 1000,\n  num_steps = 200,\n)\n")),(0,s.mdx)("p",null,"The parameters to ",(0,s.mdx)("inlineCode",{parentName:"p"},"infer")," are described below:"),(0,s.mdx)("table",null,(0,s.mdx)("thead",{parentName:"table"},(0,s.mdx)("tr",{parentName:"thead"},(0,s.mdx)("th",{parentName:"tr",align:null},"Name"),(0,s.mdx)("th",{parentName:"tr",align:null},"Usage"))),(0,s.mdx)("tbody",{parentName:"table"},(0,s.mdx)("tr",{parentName:"tbody"},(0,s.mdx)("td",{parentName:"tr",align:null},(0,s.mdx)("inlineCode",{parentName:"td"},"queries")),(0,s.mdx)("td",{parentName:"tr",align:null},"A ",(0,s.mdx)("inlineCode",{parentName:"td"},"List")," of ",(0,s.mdx)("inlineCode",{parentName:"td"},"@bm.random_variable")," targets to fit posterior distributions for.")),(0,s.mdx)("tr",{parentName:"tbody"},(0,s.mdx)("td",{parentName:"tr",align:null},(0,s.mdx)("inlineCode",{parentName:"td"},"observations")),(0,s.mdx)("td",{parentName:"tr",align:null},"The ",(0,s.mdx)("inlineCode",{parentName:"td"},"Dict")," of observations. Each key is a random variable, and its value is the observed value for that random variable.")),(0,s.mdx)("tr",{parentName:"tbody"},(0,s.mdx)("td",{parentName:"tr",align:null},(0,s.mdx)("inlineCode",{parentName:"td"},"num_samples")),(0,s.mdx)("td",{parentName:"tr",align:null},"Number of samples to build up distributions for the values listed in ",(0,s.mdx)("inlineCode",{parentName:"td"},"queries"),".")),(0,s.mdx)("tr",{parentName:"tbody"},(0,s.mdx)("td",{parentName:"tr",align:null},(0,s.mdx)("inlineCode",{parentName:"td"},"num_chains")),(0,s.mdx)("td",{parentName:"tr",align:null},"Number of separate inference runs to use. Multiple chains can be used by diagnostics to verify inference ran correctly.")))))}c.isMDXComponent=!0}}]);